{
  "version": 3,
  "sources": ["../../rxjs/src/internal/observable/dom/WebSocketSubject.ts", "../../rxjs/src/internal/observable/dom/webSocket.ts"],
  "sourcesContent": ["import { Subject, AnonymousSubject } from '../../Subject';\nimport { Subscriber } from '../../Subscriber';\nimport { Observable } from '../../Observable';\nimport { Subscription } from '../../Subscription';\nimport { Operator } from '../../Operator';\nimport { ReplaySubject } from '../../ReplaySubject';\nimport { Observer, NextObserver } from '../../types';\n\n/**\n * WebSocketSubjectConfig is a plain Object that allows us to make our\n * webSocket configurable.\n *\n * <span class=\"informal\">Provides flexibility to {@link webSocket}</span>\n *\n * It defines a set of properties to provide custom behavior in specific\n * moments of the socket's lifecycle. When the connection opens we can\n * use `openObserver`, when the connection is closed `closeObserver`, if we\n * are interested in listening for data coming from server: `deserializer`,\n * which allows us to customize the deserialization strategy of data before passing it\n * to the socket client. By default, `deserializer` is going to apply `JSON.parse` to each message coming\n * from the Server.\n *\n * ## Examples\n *\n * **deserializer**, the default for this property is `JSON.parse` but since there are just two options\n * for incoming data, either be text or binary data. We can apply a custom deserialization strategy\n * or just simply skip the default behaviour.\n *\n * ```ts\n * import { webSocket } from 'rxjs/webSocket';\n *\n * const wsSubject = webSocket({\n *   url: 'ws://localhost:8081',\n *   //Apply any transformation of your choice.\n *   deserializer: ({ data }) => data\n * });\n *\n * wsSubject.subscribe(console.log);\n *\n * // Let's suppose we have this on the Server: ws.send('This is a msg from the server')\n * //output\n * //\n * // This is a msg from the server\n * ```\n *\n * **serializer** allows us to apply custom serialization strategy but for the outgoing messages.\n *\n * ```ts\n * import { webSocket } from 'rxjs/webSocket';\n *\n * const wsSubject = webSocket({\n *   url: 'ws://localhost:8081',\n *   // Apply any transformation of your choice.\n *   serializer: msg => JSON.stringify({ channel: 'webDevelopment', msg: msg })\n * });\n *\n * wsSubject.subscribe(() => subject.next('msg to the server'));\n *\n * // Let's suppose we have this on the Server:\n * //   ws.on('message', msg => console.log);\n * //   ws.send('This is a msg from the server');\n * // output at server side:\n * //\n * // {\"channel\":\"webDevelopment\",\"msg\":\"msg to the server\"}\n * ```\n *\n * **closeObserver** allows us to set a custom error when an error raises up.\n *\n * ```ts\n * import { webSocket } from 'rxjs/webSocket';\n *\n * const wsSubject = webSocket({\n *   url: 'ws://localhost:8081',\n *   closeObserver: {\n *     next() {\n *       const customError = { code: 6666, reason: 'Custom evil reason' }\n *       console.log(`code: ${ customError.code }, reason: ${ customError.reason }`);\n *     }\n *   }\n * });\n *\n * // output\n * // code: 6666, reason: Custom evil reason\n * ```\n *\n * **openObserver**, Let's say we need to make some kind of init task before sending/receiving msgs to the\n * webSocket or sending notification that the connection was successful, this is when\n * openObserver is useful for.\n *\n * ```ts\n * import { webSocket } from 'rxjs/webSocket';\n *\n * const wsSubject = webSocket({\n *   url: 'ws://localhost:8081',\n *   openObserver: {\n *     next: () => {\n *       console.log('Connection ok');\n *     }\n *   }\n * });\n *\n * // output\n * // Connection ok\n * ```\n */\nexport interface WebSocketSubjectConfig<T> {\n  /** The url of the socket server to connect to */\n  url: string;\n  /** The protocol to use to connect */\n  protocol?: string | Array<string>;\n  /** @deprecated Will be removed in v8. Use {@link deserializer} instead. */\n  resultSelector?: (e: MessageEvent) => T;\n  /**\n   * A serializer used to create messages from passed values before the\n   * messages are sent to the server. Defaults to JSON.stringify.\n   */\n  serializer?: (value: T) => WebSocketMessage;\n  /**\n   * A deserializer used for messages arriving on the socket from the\n   * server. Defaults to JSON.parse.\n   */\n  deserializer?: (e: MessageEvent) => T;\n  /**\n   * An Observer that watches when open events occur on the underlying web socket.\n   */\n  openObserver?: NextObserver<Event>;\n  /**\n   * An Observer that watches when close events occur on the underlying web socket\n   */\n  closeObserver?: NextObserver<CloseEvent>;\n  /**\n   * An Observer that watches when a close is about to occur due to\n   * unsubscription.\n   */\n  closingObserver?: NextObserver<void>;\n  /**\n   * A WebSocket constructor to use. This is useful for situations like using a\n   * WebSocket impl in Node (WebSocket is a DOM API), or for mocking a WebSocket\n   * for testing purposes\n   */\n  WebSocketCtor?: { new (url: string, protocols?: string | string[]): WebSocket };\n  /** Sets the `binaryType` property of the underlying WebSocket. */\n  binaryType?: 'blob' | 'arraybuffer';\n}\n\nconst DEFAULT_WEBSOCKET_CONFIG: WebSocketSubjectConfig<any> = {\n  url: '',\n  deserializer: (e: MessageEvent) => JSON.parse(e.data),\n  serializer: (value: any) => JSON.stringify(value),\n};\n\nconst WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT =\n  'WebSocketSubject.error must be called with an object with an error code, and an optional reason: { code: number, reason: string }';\n\nexport type WebSocketMessage = string | ArrayBuffer | Blob | ArrayBufferView;\n\nexport class WebSocketSubject<T> extends AnonymousSubject<T> {\n  // @ts-ignore: Property has no initializer and is not definitely assigned\n  private _config: WebSocketSubjectConfig<T>;\n\n  /** @internal */\n  // @ts-ignore: Property has no initializer and is not definitely assigned\n  _output: Subject<T>;\n\n  private _socket: WebSocket | null = null;\n\n  constructor(urlConfigOrSource: string | WebSocketSubjectConfig<T> | Observable<T>, destination?: Observer<T>) {\n    super();\n    if (urlConfigOrSource instanceof Observable) {\n      this.destination = destination;\n      this.source = urlConfigOrSource as Observable<T>;\n    } else {\n      const config = (this._config = { ...DEFAULT_WEBSOCKET_CONFIG });\n      this._output = new Subject<T>();\n      if (typeof urlConfigOrSource === 'string') {\n        config.url = urlConfigOrSource;\n      } else {\n        for (const key in urlConfigOrSource) {\n          if (urlConfigOrSource.hasOwnProperty(key)) {\n            (config as any)[key] = (urlConfigOrSource as any)[key];\n          }\n        }\n      }\n\n      if (!config.WebSocketCtor && WebSocket) {\n        config.WebSocketCtor = WebSocket;\n      } else if (!config.WebSocketCtor) {\n        throw new Error('no WebSocket constructor can be found');\n      }\n      this.destination = new ReplaySubject();\n    }\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  lift<R>(operator: Operator<T, R>): WebSocketSubject<R> {\n    const sock = new WebSocketSubject<R>(this._config as WebSocketSubjectConfig<any>, this.destination as any);\n    sock.operator = operator;\n    sock.source = this;\n    return sock;\n  }\n\n  private _resetState() {\n    this._socket = null;\n    if (!this.source) {\n      this.destination = new ReplaySubject();\n    }\n    this._output = new Subject<T>();\n  }\n\n  /**\n   * Creates an {@link Observable}, that when subscribed to, sends a message,\n   * defined by the `subMsg` function, to the server over the socket to begin a\n   * subscription to data over that socket. Once data arrives, the\n   * `messageFilter` argument will be used to select the appropriate data for\n   * the resulting Observable. When finalization occurs, either due to\n   * unsubscription, completion, or error, a message defined by the `unsubMsg`\n   * argument will be sent to the server over the WebSocketSubject.\n   *\n   * @param subMsg A function to generate the subscription message to be sent to\n   * the server. This will still be processed by the serializer in the\n   * WebSocketSubject's config. (Which defaults to JSON serialization)\n   * @param unsubMsg A function to generate the unsubscription message to be\n   * sent to the server at finalization. This will still be processed by the\n   * serializer in the WebSocketSubject's config.\n   * @param messageFilter A predicate for selecting the appropriate messages\n   * from the server for the output stream.\n   */\n  multiplex(subMsg: () => any, unsubMsg: () => any, messageFilter: (value: T) => boolean) {\n    const self = this;\n    return new Observable((observer: Observer<T>) => {\n      try {\n        self.next(subMsg());\n      } catch (err) {\n        observer.error(err);\n      }\n\n      const subscription = self.subscribe({\n        next: (x) => {\n          try {\n            if (messageFilter(x)) {\n              observer.next(x);\n            }\n          } catch (err) {\n            observer.error(err);\n          }\n        },\n        error: (err) => observer.error(err),\n        complete: () => observer.complete(),\n      });\n\n      return () => {\n        try {\n          self.next(unsubMsg());\n        } catch (err) {\n          observer.error(err);\n        }\n        subscription.unsubscribe();\n      };\n    });\n  }\n\n  private _connectSocket() {\n    const { WebSocketCtor, protocol, url, binaryType } = this._config;\n    const observer = this._output;\n\n    let socket: WebSocket | null = null;\n    try {\n      socket = protocol ? new WebSocketCtor!(url, protocol) : new WebSocketCtor!(url);\n      this._socket = socket;\n      if (binaryType) {\n        this._socket.binaryType = binaryType;\n      }\n    } catch (e) {\n      observer.error(e);\n      return;\n    }\n\n    const subscription = new Subscription(() => {\n      this._socket = null;\n      if (socket && socket.readyState === 1) {\n        socket.close();\n      }\n    });\n\n    socket.onopen = (evt: Event) => {\n      const { _socket } = this;\n      if (!_socket) {\n        socket!.close();\n        this._resetState();\n        return;\n      }\n      const { openObserver } = this._config;\n      if (openObserver) {\n        openObserver.next(evt);\n      }\n\n      const queue = this.destination;\n\n      this.destination = Subscriber.create<T>(\n        (x) => {\n          if (socket!.readyState === 1) {\n            try {\n              const { serializer } = this._config;\n              socket!.send(serializer!(x!));\n            } catch (e) {\n              this.destination!.error(e);\n            }\n          }\n        },\n        (err) => {\n          const { closingObserver } = this._config;\n          if (closingObserver) {\n            closingObserver.next(undefined);\n          }\n          if (err && err.code) {\n            socket!.close(err.code, err.reason);\n          } else {\n            observer.error(new TypeError(WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT));\n          }\n          this._resetState();\n        },\n        () => {\n          const { closingObserver } = this._config;\n          if (closingObserver) {\n            closingObserver.next(undefined);\n          }\n          socket!.close();\n          this._resetState();\n        }\n      ) as Subscriber<any>;\n\n      if (queue && queue instanceof ReplaySubject) {\n        subscription.add((queue as ReplaySubject<T>).subscribe(this.destination));\n      }\n    };\n\n    socket.onerror = (e: Event) => {\n      this._resetState();\n      observer.error(e);\n    };\n\n    socket.onclose = (e: CloseEvent) => {\n      if (socket === this._socket) {\n        this._resetState();\n      }\n      const { closeObserver } = this._config;\n      if (closeObserver) {\n        closeObserver.next(e);\n      }\n      if (e.wasClean) {\n        observer.complete();\n      } else {\n        observer.error(e);\n      }\n    };\n\n    socket.onmessage = (e: MessageEvent) => {\n      try {\n        const { deserializer } = this._config;\n        observer.next(deserializer!(e));\n      } catch (err) {\n        observer.error(err);\n      }\n    };\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    const { source } = this;\n    if (source) {\n      return source.subscribe(subscriber);\n    }\n    if (!this._socket) {\n      this._connectSocket();\n    }\n    this._output.subscribe(subscriber);\n    subscriber.add(() => {\n      const { _socket } = this;\n      if (this._output.observers.length === 0) {\n        if (_socket && (_socket.readyState === 1 || _socket.readyState === 0)) {\n          _socket.close();\n        }\n        this._resetState();\n      }\n    });\n    return subscriber;\n  }\n\n  unsubscribe() {\n    const { _socket } = this;\n    if (_socket && (_socket.readyState === 1 || _socket.readyState === 0)) {\n      _socket.close();\n    }\n    this._resetState();\n    super.unsubscribe();\n  }\n}\n", "import { WebSocketSubject, WebSocketSubjectConfig } from './WebSocketSubject';\n\n/**\n * Wrapper around the w3c-compatible WebSocket object provided by the browser.\n *\n * <span class=\"informal\">{@link Subject} that communicates with a server via WebSocket</span>\n *\n * `webSocket` is a factory function that produces a `WebSocketSubject`,\n * which can be used to make WebSocket connection with an arbitrary endpoint.\n * `webSocket` accepts as an argument either a string with url of WebSocket endpoint, or an\n * {@link WebSocketSubjectConfig} object for providing additional configuration, as\n * well as Observers for tracking lifecycle of WebSocket connection.\n *\n * When `WebSocketSubject` is subscribed, it attempts to make a socket connection,\n * unless there is one made already. This means that many subscribers will always listen\n * on the same socket, thus saving resources. If however, two instances are made of `WebSocketSubject`,\n * even if these two were provided with the same url, they will attempt to make separate\n * connections. When consumer of a `WebSocketSubject` unsubscribes, socket connection is closed,\n * only if there are no more subscribers still listening. If after some time a consumer starts\n * subscribing again, connection is reestablished.\n *\n * Once connection is made, whenever a new message comes from the server, `WebSocketSubject` will emit that\n * message as a value in the stream. By default, a message from the socket is parsed via `JSON.parse`. If you\n * want to customize how deserialization is handled (if at all), you can provide custom `resultSelector`\n * function in {@link WebSocketSubject}. When connection closes, stream will complete, provided it happened without\n * any errors. If at any point (starting, maintaining or closing a connection) there is an error,\n * stream will also error with whatever WebSocket API has thrown.\n *\n * By virtue of being a {@link Subject}, `WebSocketSubject` allows for receiving and sending messages from the server. In order\n * to communicate with a connected endpoint, use `next`, `error` and `complete` methods. `next` sends a value to the server, so bear in mind\n * that this value will not be serialized beforehand. Because of This, `JSON.stringify` will have to be called on a value by hand,\n * before calling `next` with a result. Note also that if at the moment of nexting value\n * there is no socket connection (for example no one is subscribing), those values will be buffered, and sent when connection\n * is finally established. `complete` method closes socket connection. `error` does the same,\n * as well as notifying the server that something went wrong via status code and string with details of what happened.\n * Since status code is required in WebSocket API, `WebSocketSubject` does not allow, like regular `Subject`,\n * arbitrary values being passed to the `error` method. It needs to be called with an object that has `code`\n * property with status code number and optional `reason` property with string describing details\n * of an error.\n *\n * Calling `next` does not affect subscribers of `WebSocketSubject` - they have no\n * information that something was sent to the server (unless of course the server\n * responds somehow to a message). On the other hand, since calling `complete` triggers\n * an attempt to close socket connection. If that connection is closed without any errors, stream will\n * complete, thus notifying all subscribers. And since calling `error` closes\n * socket connection as well, just with a different status code for the server, if closing itself proceeds\n * without errors, subscribed Observable will not error, as one might expect, but complete as usual. In both cases\n * (calling `complete` or `error`), if process of closing socket connection results in some errors, *then* stream\n * will error.\n *\n * **Multiplexing**\n *\n * `WebSocketSubject` has an additional operator, not found in other Subjects. It is called `multiplex` and it is\n * used to simulate opening several socket connections, while in reality maintaining only one.\n * For example, an application has both chat panel and real-time notifications about sport news. Since these are two distinct functions,\n * it would make sense to have two separate connections for each. Perhaps there could even be two separate services with WebSocket\n * endpoints, running on separate machines with only GUI combining them together. Having a socket connection\n * for each functionality could become too resource expensive. It is a common pattern to have single\n * WebSocket endpoint that acts as a gateway for the other services (in this case chat and sport news services).\n * Even though there is a single connection in a client app, having the ability to manipulate streams as if it\n * were two separate sockets is desirable. This eliminates manually registering and unregistering in a gateway for\n * given service and filter out messages of interest. This is exactly what `multiplex` method is for.\n *\n * Method accepts three parameters. First two are functions returning subscription and unsubscription messages\n * respectively. These are messages that will be sent to the server, whenever consumer of resulting Observable\n * subscribes and unsubscribes. Server can use them to verify that some kind of messages should start or stop\n * being forwarded to the client. In case of the above example application, after getting subscription message with proper identifier,\n * gateway server can decide that it should connect to real sport news service and start forwarding messages from it.\n * Note that both messages will be sent as returned by the functions, they are by default serialized using JSON.stringify, just\n * as messages pushed via `next`. Also bear in mind that these messages will be sent on *every* subscription and\n * unsubscription. This is potentially dangerous, because one consumer of an Observable may unsubscribe and the server\n * might stop sending messages, since it got unsubscription message. This needs to be handled\n * on the server or using {@link publish} on a Observable returned from 'multiplex'.\n *\n * Last argument to `multiplex` is a `messageFilter` function which should return a boolean. It is used to filter out messages\n * sent by the server to only those that belong to simulated WebSocket stream. For example, server might mark these\n * messages with some kind of string identifier on a message object and `messageFilter` would return `true`\n * if there is such identifier on an object emitted by the socket. Messages which returns `false` in `messageFilter` are simply skipped,\n * and are not passed down the stream.\n *\n * Return value of `multiplex` is an Observable with messages incoming from emulated socket connection. Note that this\n * is not a `WebSocketSubject`, so calling `next` or `multiplex` again will fail. For pushing values to the\n * server, use root `WebSocketSubject`.\n *\n * ## Examples\n *\n * Listening for messages from the server\n *\n * ```ts\n * import { webSocket } from 'rxjs/webSocket';\n *\n * const subject = webSocket('ws://localhost:8081');\n *\n * subject.subscribe({\n *   next: msg => console.log('message received: ' + msg), // Called whenever there is a message from the server.\n *   error: err => console.log(err), // Called if at any point WebSocket API signals some kind of error.\n *   complete: () => console.log('complete') // Called when connection is closed (for whatever reason).\n *  });\n * ```\n *\n * Pushing messages to the server\n *\n * ```ts\n * import { webSocket } from 'rxjs/webSocket';\n *\n * const subject = webSocket('ws://localhost:8081');\n *\n * subject.subscribe();\n * // Note that at least one consumer has to subscribe to the created subject - otherwise \"nexted\" values will be just buffered and not sent,\n * // since no connection was established!\n *\n * subject.next({ message: 'some message' });\n * // This will send a message to the server once a connection is made. Remember value is serialized with JSON.stringify by default!\n *\n * subject.complete(); // Closes the connection.\n *\n * subject.error({ code: 4000, reason: 'I think our app just broke!' });\n * // Also closes the connection, but let's the server know that this closing is caused by some error.\n * ```\n *\n * Multiplexing WebSocket\n *\n * ```ts\n * import { webSocket } from 'rxjs/webSocket';\n *\n * const subject = webSocket('ws://localhost:8081');\n *\n * const observableA = subject.multiplex(\n *   () => ({ subscribe: 'A' }), // When server gets this message, it will start sending messages for 'A'...\n *   () => ({ unsubscribe: 'A' }), // ...and when gets this one, it will stop.\n *   message => message.type === 'A' // If the function returns `true` message is passed down the stream. Skipped if the function returns false.\n * );\n *\n * const observableB = subject.multiplex( // And the same goes for 'B'.\n *   () => ({ subscribe: 'B' }),\n *   () => ({ unsubscribe: 'B' }),\n *   message => message.type === 'B'\n * );\n *\n * const subA = observableA.subscribe(messageForA => console.log(messageForA));\n * // At this moment WebSocket connection is established. Server gets '{\"subscribe\": \"A\"}' message and starts sending messages for 'A',\n * // which we log here.\n *\n * const subB = observableB.subscribe(messageForB => console.log(messageForB));\n * // Since we already have a connection, we just send '{\"subscribe\": \"B\"}' message to the server. It starts sending messages for 'B',\n * // which we log here.\n *\n * subB.unsubscribe();\n * // Message '{\"unsubscribe\": \"B\"}' is sent to the server, which stops sending 'B' messages.\n *\n * subA.unsubscribe();\n * // Message '{\"unsubscribe\": \"A\"}' makes the server stop sending messages for 'A'. Since there is no more subscribers to root Subject,\n * // socket connection closes.\n * ```\n *\n * @param {string|WebSocketSubjectConfig} urlConfigOrSource The WebSocket endpoint as an url or an object with\n * configuration and additional Observers.\n * @return {WebSocketSubject} Subject which allows to both send and receive messages via WebSocket connection.\n */\nexport function webSocket<T>(urlConfigOrSource: string | WebSocketSubjectConfig<T>): WebSocketSubject<T> {\n  return new WebSocketSubject<T>(urlConfigOrSource);\n}\n"],
  "mappings": ";;;;;;;;;;;;;AAiJA,IAAM,2BAAwD;EAC5D,KAAK;EACL,cAAc,SAAC,GAAe;AAAK,WAAA,KAAK,MAAM,EAAE,IAAI;EAAjB;EACnC,YAAY,SAAC,OAAU;AAAK,WAAA,KAAK,UAAU,KAAK;EAApB;;AAG9B,IAAM,wCACJ;AAIF,IAAA,mBAAA,SAAA,QAAA;AAAyC,YAAAA,mBAAA,MAAA;AAUvC,WAAAA,kBAAY,mBAAuE,aAAyB;AAA5G,QAAA,QACE,OAAA,KAAA,IAAA,KAAO;AAHD,UAAA,UAA4B;AAIlC,QAAI,6BAA6B,YAAY;AAC3C,YAAK,cAAc;AACnB,YAAK,SAAS;WACT;AACL,UAAM,SAAU,MAAK,UAAO,SAAA,CAAA,GAAQ,wBAAwB;AAC5D,YAAK,UAAU,IAAI,QAAO;AAC1B,UAAI,OAAO,sBAAsB,UAAU;AACzC,eAAO,MAAM;aACR;AACL,iBAAW,OAAO,mBAAmB;AACnC,cAAI,kBAAkB,eAAe,GAAG,GAAG;AACxC,mBAAe,GAAG,IAAK,kBAA0B,GAAG;;;;AAK3D,UAAI,CAAC,OAAO,iBAAiB,WAAW;AACtC,eAAO,gBAAgB;iBACd,CAAC,OAAO,eAAe;AAChC,cAAM,IAAI,MAAM,uCAAuC;;AAEzD,YAAK,cAAc,IAAI,cAAa;;;EAExC;AAGA,EAAAA,kBAAA,UAAA,OAAA,SAAQ,UAAwB;AAC9B,QAAM,OAAO,IAAIA,kBAAoB,KAAK,SAAwC,KAAK,WAAkB;AACzG,SAAK,WAAW;AAChB,SAAK,SAAS;AACd,WAAO;EACT;AAEQ,EAAAA,kBAAA,UAAA,cAAR,WAAA;AACE,SAAK,UAAU;AACf,QAAI,CAAC,KAAK,QAAQ;AAChB,WAAK,cAAc,IAAI,cAAa;;AAEtC,SAAK,UAAU,IAAI,QAAO;EAC5B;AAoBA,EAAAA,kBAAA,UAAA,YAAA,SAAU,QAAmB,UAAqB,eAAoC;AACpF,QAAM,OAAO;AACb,WAAO,IAAI,WAAW,SAAC,UAAqB;AAC1C,UAAI;AACF,aAAK,KAAK,OAAM,CAAE;eACX,KAAK;AACZ,iBAAS,MAAM,GAAG;;AAGpB,UAAM,eAAe,KAAK,UAAU;QAClC,MAAM,SAAC,GAAC;AACN,cAAI;AACF,gBAAI,cAAc,CAAC,GAAG;AACpB,uBAAS,KAAK,CAAC;;mBAEV,KAAK;AACZ,qBAAS,MAAM,GAAG;;QAEtB;QACA,OAAO,SAAC,KAAG;AAAK,iBAAA,SAAS,MAAM,GAAG;QAAlB;QAChB,UAAU,WAAA;AAAM,iBAAA,SAAS,SAAQ;QAAjB;OACjB;AAED,aAAO,WAAA;AACL,YAAI;AACF,eAAK,KAAK,SAAQ,CAAE;iBACb,KAAK;AACZ,mBAAS,MAAM,GAAG;;AAEpB,qBAAa,YAAW;MAC1B;IACF,CAAC;EACH;AAEQ,EAAAA,kBAAA,UAAA,iBAAR,WAAA;AAAA,QAAA,QAAA;AACQ,QAAA,KAA+C,KAAK,SAAlD,gBAAa,GAAA,eAAE,WAAQ,GAAA,UAAE,MAAG,GAAA,KAAE,aAAU,GAAA;AAChD,QAAM,WAAW,KAAK;AAEtB,QAAI,SAA2B;AAC/B,QAAI;AACF,eAAS,WAAW,IAAI,cAAe,KAAK,QAAQ,IAAI,IAAI,cAAe,GAAG;AAC9E,WAAK,UAAU;AACf,UAAI,YAAY;AACd,aAAK,QAAQ,aAAa;;aAErB,GAAG;AACV,eAAS,MAAM,CAAC;AAChB;;AAGF,QAAM,eAAe,IAAI,aAAa,WAAA;AACpC,YAAK,UAAU;AACf,UAAI,UAAU,OAAO,eAAe,GAAG;AACrC,eAAO,MAAK;;IAEhB,CAAC;AAED,WAAO,SAAS,SAAC,KAAU;AACjB,UAAA,UAAY,MAAI;AACxB,UAAI,CAAC,SAAS;AACZ,eAAQ,MAAK;AACb,cAAK,YAAW;AAChB;;AAEM,UAAA,eAAiB,MAAK,QAAO;AACrC,UAAI,cAAc;AAChB,qBAAa,KAAK,GAAG;;AAGvB,UAAM,QAAQ,MAAK;AAEnB,YAAK,cAAc,WAAW,OAC5B,SAAC,GAAC;AACA,YAAI,OAAQ,eAAe,GAAG;AAC5B,cAAI;AACM,gBAAA,aAAe,MAAK,QAAO;AACnC,mBAAQ,KAAK,WAAY,CAAE,CAAC;mBACrB,GAAG;AACV,kBAAK,YAAa,MAAM,CAAC;;;MAG/B,GACA,SAAC,KAAG;AACM,YAAA,kBAAoB,MAAK,QAAO;AACxC,YAAI,iBAAiB;AACnB,0BAAgB,KAAK,MAAS;;AAEhC,YAAI,OAAO,IAAI,MAAM;AACnB,iBAAQ,MAAM,IAAI,MAAM,IAAI,MAAM;eAC7B;AACL,mBAAS,MAAM,IAAI,UAAU,qCAAqC,CAAC;;AAErE,cAAK,YAAW;MAClB,GACA,WAAA;AACU,YAAA,kBAAoB,MAAK,QAAO;AACxC,YAAI,iBAAiB;AACnB,0BAAgB,KAAK,MAAS;;AAEhC,eAAQ,MAAK;AACb,cAAK,YAAW;MAClB,CAAC;AAGH,UAAI,SAAS,iBAAiB,eAAe;AAC3C,qBAAa,IAAK,MAA2B,UAAU,MAAK,WAAW,CAAC;;IAE5E;AAEA,WAAO,UAAU,SAAC,GAAQ;AACxB,YAAK,YAAW;AAChB,eAAS,MAAM,CAAC;IAClB;AAEA,WAAO,UAAU,SAAC,GAAa;AAC7B,UAAI,WAAW,MAAK,SAAS;AAC3B,cAAK,YAAW;;AAEV,UAAA,gBAAkB,MAAK,QAAO;AACtC,UAAI,eAAe;AACjB,sBAAc,KAAK,CAAC;;AAEtB,UAAI,EAAE,UAAU;AACd,iBAAS,SAAQ;aACZ;AACL,iBAAS,MAAM,CAAC;;IAEpB;AAEA,WAAO,YAAY,SAAC,GAAe;AACjC,UAAI;AACM,YAAA,eAAiB,MAAK,QAAO;AACrC,iBAAS,KAAK,aAAc,CAAC,CAAC;eACvB,KAAK;AACZ,iBAAS,MAAM,GAAG;;IAEtB;EACF;AAGU,EAAAA,kBAAA,UAAA,aAAV,SAAqB,YAAyB;AAA9C,QAAA,QAAA;AACU,QAAA,SAAW,KAAI;AACvB,QAAI,QAAQ;AACV,aAAO,OAAO,UAAU,UAAU;;AAEpC,QAAI,CAAC,KAAK,SAAS;AACjB,WAAK,eAAc;;AAErB,SAAK,QAAQ,UAAU,UAAU;AACjC,eAAW,IAAI,WAAA;AACL,UAAA,UAAY,MAAI;AACxB,UAAI,MAAK,QAAQ,UAAU,WAAW,GAAG;AACvC,YAAI,YAAY,QAAQ,eAAe,KAAK,QAAQ,eAAe,IAAI;AACrE,kBAAQ,MAAK;;AAEf,cAAK,YAAW;;IAEpB,CAAC;AACD,WAAO;EACT;AAEA,EAAAA,kBAAA,UAAA,cAAA,WAAA;AACU,QAAA,UAAY,KAAI;AACxB,QAAI,YAAY,QAAQ,eAAe,KAAK,QAAQ,eAAe,IAAI;AACrE,cAAQ,MAAK;;AAEf,SAAK,YAAW;AAChB,WAAA,UAAM,YAAW,KAAA,IAAA;EACnB;AACF,SAAAA;AAAA,EAhPyC,gBAAgB;;;ACGnD,SAAU,UAAa,mBAAqD;AAChF,SAAO,IAAI,iBAAoB,iBAAiB;AAClD;",
  "names": ["WebSocketSubject"]
}
